---
title:
  Under the magnifying glass. Dimensions of variation in the contemporary Timok variety
subtitle:
  Documentation
author: Teodora Vuković
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    # includes:
    #   in_header: traceba_logo.html
  word_document:
    toc: true
  pdf_document:
    toc: true
    toc_depth: 3
    includes: 
      in_header: 
        preamble.tex
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)


library(tinytex)

library(ggplot2)
library(ggrepel)
library(ggmosaic)
library(gridExtra)

library(tidyverse)
library(reshape)
library(vcd)
library(viridis)
library(plyr)
library(stats)
library(leaflet)
library(vcd)
library(stats)
```

## Introduction

The present document is appendix to the manuscript Under the magnifying glass. Dimensions of variation in the contemporary Timok variety.

The manuscript deals with morphosyntactic and socio-geographic variation in a South Slavic Timok variety spoken in Southeast Serbia. Four linguistic features are analysed in the context of variation between East South Slavic/Standard Serbian on the one side, and Balkan Slavic/non-standard on the other. The features selected for the analysis are:

- marking of indirect object and possessor 
- post-positive demonstratives
- dative reflexive *si* as a particle
- auxiliary omission in the perfect tense 

The present document follows the analysis presented in the paper and provides data and methodological processes used. It thus orderly refers to the sections and subsections from the manuscript.

For the purposes of the present paper, corpus files were searched using Python. The published online version of the corpus might provide different search options. Should the search be repeated on the uploaded version of the corpus, due to potential fine-grained changes in the data, the tendencies presented in the paper will not change, but the absolute numbers might, as well as the overall number of examples.

Note that in the present document, some pieces of code have been hidden to make it more readable. The entire code is available in the source script with the .Rmd extension.

## 3. Facets of variation

## 3.1 The analysis of morphosyntactic factors

### 3.1.1 Marking of indirect object and possessor

The analysis is based on the following variables:

- Dependent variable: type of marking (*na* + general oblique case vs. inflectional dative)
- Independent variables: function (indirect object, possessor), part-of-speech (nouns, pronouns, ‘other’), nominal categories (proper/common nouns, grammatical number, grammatical gender, animacy)

The data used in the analysis is stored in the file 1_data.xlsx. The data was extracted from the corpus semi-automatically. Firstly Python script was used to extract all the instances of dative or *na* + noun/pronoun patterns.

00_IO_na_search.py

00_IO_dative_search.py

Noun forms were approximated using word endings for inflected and non-inflected forms. For pronouns, a list of all pronominal forms was used (see in scripts). The list of verbs was added as an additional means to enable better search and ensure that particular verbs will be retrieved (see in scripts). The obtained examples of IO are not just based on the pre-defined list of verbs, other contexts were  included as well.

This data was then filtered manually example, by example. The final list of examples was labelled manually for the perametres included in the analysis. The filtered data was further segmented by focusing on particular criteria for each analysis. The overall number of examples is 895.

Frequencies of *na* ‘on’ + general oblique case and inflectional dative are normalized with regard to the overall number of relevant parts of speech and nominal categories retrieved from the corpus and multiplied with 10,000 in case of the PoS, gender and number, but with 1,000 in case of type of noun and animacy.

The file 1_marking_examples.xlsx is organized in sheets as follows:

1. Case, PoS, Function - rows contain examples extracted from the corpus. Columns contain information about Case, Function, PoS for each example (manually annotated) 
2. IO PoS RAW - data from Case, PoS, Function, only for IO. It contains also a summary table with absolute frequencies regarding PoS.
3. POSS PoS RAW - data from Case, PoS, Function, only for POSS. It contains also a summary table with absolute frequencies regarding PoS.
4. Freq PoS tabele - repeated summary tables from 2. IO PoS RAW and 3. POSS PoS RAW, with calculated percentages, normalized per total number of the respective category.
5. Nominal categories RAW data - (for nouns only!) rows contain examples extracted from the corpus. Columns contain informtaion about nominal categories: Type of Noun (proper, common), Gender (masculine, feminine, neuter), Number (singular, plural), Animacy (animate, inanimate). 
6. % for Nominal categories - Summary table based on data from 5. Nominal categories RAW data, with percentages and normalized frequencies per total number of nouns of each type/gender/number/animacy. The data for Type of Nouns is marked in yellow. The final table used for Figure 3 is highlited in red.
7. corpus_PoS_frequencies - frequencies extracted from the corpus for each PoS and nominal categories. The last row shows total frequency for each column.

In what follows analyses are presented as they appear in the paper.

Chi square test is used to compare analysed observations of analytic vs. inflectional marking in the whole sample. The test is performed using the data in the file 1_analytic_synthetic_marking.csv' which contains all examples of IO and POSS extracted from the corpus, labelled for the type of marking: analytic=0, inflectional=1 (from the file 1_data.xlsx, sheet 1. Case, PoS, Function, column Case). The values were relabelled below 0="NA+OBL", 1="DAT" here for clearer representation.


```{r include=FALSE}
marking_function_pos = read.csv('1_marking_function_pos.csv', header = TRUE, sep = "\t", stringsAsFactors = TRUE, strip.white=TRUE)

analytic_synthetic_marking_chisq = table(marking_function_pos$Case)
```
```{r }
head(marking_function_pos)
```


The sum of each category is used as input for Chi-square test.


```{r }
head(analytic_synthetic_marking_chisq)
chisq.test(analytic_synthetic_marking_chisq)

```


Logistic regression is used to compare frequencies of analytic and inflectional type of marking with regard to their function (indirect object, possessive) and the part og speech (noun, pronoun). 


```{r include=FALSE}
marking_function_pos$Case<-relevel(marking_function_pos$Case, ref = "na-OBL")
model_function_pos_2 <- glm(Case ~ Function + PoS + Function:PoS, family=binomial, data=marking_function_pos)
```
```{r }
summary(model_function_pos_2)
```


The more frequent values are taken as the baseline: na-OBL, IO, NOUN.

Odds ratio:

```{r}
exp(model_function_pos_2$coefficients)
```


The proportion of each category is visualised in Figure 1, based on the data from the file marking_function_pos.csv. The data was obtained by categorizing each example based on the type of marking and function (see 1_data.xlsx, 1. Case, PoS, Function, columns Case and funciton).


```{r include=FALSE}
Case = marking_function_pos$Case
Function = marking_function_pos$Function
PoS = marking_function_pos$PoS
case.function = xtabs(~ Case + Function)
case.pos = xtabs(~ Case + PoS)
case.function.pos = xtabs(~ Case + Function + PoS)
```
```{r fig.height=5, fig.width=10}

# Mosaic 1: Case~function
# run all the lines of code together for the version from the paper
mosaic(case.function, main = "", direction = "v", labeling = labeling_values)
# grid.edit("rect:Case=DAT,Function=POSS", gp = gpar(fill = "gray50"))
# grid.edit("rect:Case=DAT,Function=IO", gp = gpar(fill = "gray50"))

```
```{r fig.height=5, fig.width=10}


# Mosaic 2: Case~PoS
# run all the lines of code together for the version from the paper
mosaic(case.pos, main = "", direction = "v", labeling = labeling_values)
# grid.edit("rect:Case=DAT,PoS=NOUN", gp = gpar(fill = "gray50"))
# grid.edit("rect:Case=DAT,PoS=PRONOUN", gp = gpar(fill = "gray50"))

```
```{r fig.height=5, fig.width=10}

# Mosaic 3: Case~function~PoS
# run all the lines of code together for the version from the paper
mosaic(case.function.pos, main = "", direction = "v", labeling = labeling_values)
# grid.edit("rect:Case=DAT,Function=POSS,PoS=NOUN", gp = gpar(fill = "gray50"))
# grid.edit("rect:Case=DAT,Function=POSS,PoS=PRONOUN", gp = gpar(fill = "gray50"))
# grid.edit("rect:Case=DAT,Function=IO,PoS=NOUN", gp = gpar(fill = "gray50"))
# grid.edit("rect:Case=DAT,Function=IO,PoS=PRONOUN", gp = gpar(fill = "gray50"))



```


Regression analysis of the effect of the nominal categories on the use of analytic or synthetic marking.


```{r include=FALSE}

marking_nominal_categories=read.delim("1_marking_nominal_categories.csv")

marking_nominal_categories$Case<-as.factor(marking_nominal_categories$Case)
marking_nominal_categories$Number<-as.factor(marking_nominal_categories$Number)
marking_nominal_categories$ReferenceToPersons<-as.factor(marking_nominal_categories$ReferenceToPersons)
marking_nominal_categories$Case<-relevel(marking_nominal_categories$Case, "na-OBL")
marking_nominal_categories$Number<-relevel(marking_nominal_categories$Number, "SG")
marking_nominal_categories$ReferenceToPersons<-relevel(marking_nominal_categories$ReferenceToPersons, "YES")

model_nominal_categories_5 <- glm(Case ~ NounType + Gender + Number + ReferenceToPersons + Gender:Number + Gender:ReferenceToPersons + Gender:NounType + Number:NounType, family=binomial, data=marking_nominal_categories)

```
```{r}
summary(model_nominal_categories_5)
```
```{r}
exp(model_nominal_categories_5$coefficients)
```
```{r include=FALSE}
Case = marking_nominal_categories$Case
NounType = marking_nominal_categories$NounType
Gender = marking_nominal_categories$Gender
Number = marking_nominal_categories$Number
Animacy = marking_nominal_categories$Animacy
ReferenceToPersons = marking_nominal_categories$ReferenceToPersons
case.nountype = xtabs(~ Case + NounType)
case.gender = xtabs(~ Case + Gender)
case.number = xtabs(~ Case + Number)
case.animacy = xtabs(~ Case + Animacy)
case.reftopers = xtabs(~ Case + ReferenceToPersons)
```
```{r fig.height=5, fig.width=10, fig.keep='high'}

# mosaic_nomcat1: Case~Noun type
# run all the lines of code together for the version from the paper
mosaic(case.nountype, main = "", direction = "v", labeling = labeling_values)
# grid.edit("rect:Case=DAT,NounType=COMMON", gp = gpar(fill = "gray50"))
# grid.edit("rect:Case=DAT,NounType=PROPER", gp = gpar(fill = "gray50"))

```
```{r fig.height=5, fig.width=10}

# mosaic_nomcat2: Case~Gender
# run all the lines of code together for the version from the paper
mosaic(case.gender, main = "", direction = "v", labeling = labeling_values)
# grid.edit("rect:Case=DAT,Gender=FEM", gp = gpar(fill = "gray50"))
# grid.edit("rect:Case=DAT,Gender=MASC", gp = gpar(fill = "gray50"))
# grid.edit("rect:Case=DAT,Gender=NEUT", gp = gpar(fill = "gray50"))
```
```{r fig.height=5, fig.width=10}

# mosaic_nomcat3: Case~Number
# run all the lines of code together for the version from the paper
mosaic(case.number, main = "", direction = "v", labeling = labeling_values)
# grid.edit("rect:Case=DAT,Number=SG", gp = gpar(fill = "gray50"))
# grid.edit("rect:Case=DAT,Number=PL", gp = gpar(fill = "gray50"))
```
```{r fig.height=5, fig.width=10}

# mosaic_nomcat4: Case~Animacy
# run all the lines of code together for the version from the paper
mosaic(case.animacy, main = "", direction = "v", labeling = labeling_values)
# grid.edit("rect:Case=DAT,Animacy=ANIMATE", gp = gpar(fill = "gray50"))
# grid.edit("rect:Case=DAT,Animacy=INANIMATE", gp = gpar(fill = "gray50"))
```
```{r fig.height=5, fig.width=10}

# mosaic_nomcat5: Case~Reference to persons
# run all the lines of code together for the version from the paper
mosaic(case.reftopers, main = "", direction = "v", labeling = labeling_values)
# grid.edit("rect:Case=DAT,ReferenceToPersons=NO", gp = gpar(fill = "gray50"))
# grid.edit("rect:Case=DAT,ReferenceToPersons=YES", gp = gpar(fill = "gray50"))



```


### 3.1.2 Post-positive demonstratives

In order to identify the distribution of different forms of PPD (nominative/unmarked vs. accusative/oblique, as well based on gender), nouns containing PPD were compared against bare nouns. The comparison regarding gender includes all nouns, while the comparison concerning case takes into account only nouns of the grammatical feminine gender ending in -a and masculine animate nouns ending in a consonant (regardless of the syntactic position). The following variables were used:

- Dependent variable: frequency of the nouns containing PPD and bare nouns (absolute and normalized per 10,000 nouns)
- Independent variables: gender of nouns (masculine ending in consonant, feminine ending in -a, neuter), case of nouns (nominative/unmarked and oblique/accusative singular)

Words with PPD were extracted from the corpus based on their form. The analysis in the present study involved nouns only, as explained in the manuscript. The resulting list of nouns carrying a PPD contains 1,195 tokens (in the corpus there is a total of 1,131 words of all PoS categories carrying a PPD). These words were manually annotated for PoS categories for the purposes of the analysis, because some PoS labels retreived from the corpus had been initially wrong. The examples of words containing PPD are stored in the file 2_examples_nouns_PPD.txt.The file 2_examples_all_nouns_without_PPD.txt contains all bare nouns, 79467 of them, that were derived from the corpus using only PoS tags.
 
For the analysis of nouns based on gender genders, the data was categorized using PoS tags.

For the analysis of gender and case inflection, the extraction of nouns of different genders was done by using lists of lemmas from each of the categories: 
- grammatical feminine gender (feminine and masculine nouns ending in -a)
- animate masculine nouns ending in consonant
The lists were made by first automatically extracting all nouns of each gender from the corpus by using PoS tags and forms, and then manually selecting only correct instances. The feminine group includes the first 1337 correct lemmas, sorted by frequency. Both masculine groups contain all lemmas retreived from the corpus fitting the criteria. The lists of lemmas are available in files 2_PPD_masculine_nouns_in_a.txt, 2_PPD_masculine_animate_nouns_in_consonant.txt, 2_PPD_feminine_nouns_in_a.txt. The number of elements in each list is shown below (not included in the manuscript).


``` {r include=FALSE}
lists_of_lemmas_gender = data.frame(Category = c("Masculine animate in consonant", "Feminine in -a", "Masculine in -a"), List_size = c(336,1337,109), stringsAsFactors = TRUE)
```
```{r}
lists_of_lemmas_gender

``` 


All nouns were compared for gender, categorized based on gender and the presence of PPD. The total number of bare nouns of all genders is 74,769. The total number of nouns with PPD is 1,195. The data used in the analysis is presented in the file 2_PPD_gender_absfreq.csv.

``` {r include=FALSE}
ppd_gender=read.delim("2_ppd_gender_noun.txt")

```

The count of all nouns based on whether they carry a PPD:

```{r}
table(ppd_gender$PPDSTATUS)
chisq.test(table(ppd_gender$PPDSTATUS))
```


Absolute frequencies of each gender in bare nouns and nouns containing a PPD are presented in the file 2_ppd_gender_noun.txt.



Regression analysis between PPD status and Gender


``` {r include=FALSE}

ppd_gender$GENDER<-as.factor(ppd_gender$GENDER)
ppd_gender$PPDSTATUS<-as.factor(ppd_gender$PPDSTATUS)
ppd_gender$GENDER<-relevel(ppd_gender$GENDER, "M")


```
```{r}
model_ppd_gender <- glm(PPDSTATUS ~ GENDER, family=binomial, data=ppd_gender)
summary(model_ppd_gender)
exp(model_ppd_gender$coefficients)
```

Regression analysis between PPD status and Gender

``` {r include=FALSE}

PPD_status = ppd_gender$PPDSTATUS
Gender = ppd_gender$GENDER
ppd.gender = xtabs(~ PPD_status + Gender)

```
Proportions of each gender in bare nouns and nouns containing a PPD is shown in Figure 4.
```{r}
# run all the lines of code together for the version from the paper
mosaic(ppd.gender, main = "", direction = "v", labeling = labeling_values)
# grid.edit("rect:PPD_status=NOPPD,Gender=F", gp = gpar(fill = "gray50"))
# grid.edit("rect:PPD_status=NOPPD,Gender=M", gp = gpar(fill = "gray50"))
# grid.edit("rect:PPD_status=NOPPD,Gender=N", gp = gpar(fill = "gray50"))
```

Regression analysis between PPD status and Gender + Case

```{r include=FALSE}

ppd_gender2_case=read.delim("2_ppd_gender2_case.txt")

ppd_gender2_case$CASE<-as.factor(ppd_gender2_case$CASE)
ppd_gender2_case$PPDSTATUS<-as.factor(ppd_gender2_case$PPDSTATUS)
ppd_gender2_case$GENDER<-as.factor(ppd_gender2_case$GENDER)
```
```{r}
model_ppd_gender2_case_1 <- glm(PPDSTATUS ~ GENDER + CASE, family=binomial, data=ppd_gender2_case)
summary(model_ppd_gender2_case_1)
exp(model_ppd_gender2_case_1$coefficients)

```


Mosaic plots 2:


```{r, fig.height=3.5, fig.cap="Figure 4: PPD and gender of nouns"}


PPD_status = ppd_gender2_case$PPDSTATUS
Gender = ppd_gender2_case$GENDER
Case = ppd_gender2_case$CASE
ppd.gender.case = xtabs(~ PPD_status + Gender + Case)

# run all the lines of code together for the version from the paper
mosaic(ppd.gender.case, main = "", direction = "v", labeling = labeling_values)
# grid.edit("rect:PPD_status=NOPPD,Gender=F,Case=NOM", gp = gpar(fill = "gray50"))
# grid.edit("rect:PPD_status=NOPPD,Gender=F,Case=OBL", gp = gpar(fill = "gray50"))
# grid.edit("rect:PPD_status=NOPPD,Gender=M,Case=NOM", gp = gpar(fill = "gray50"))
# grid.edit("rect:PPD_status=NOPPD,Gender=M,Case=OBL", gp = gpar(fill = "gray50"))



```


### 3.1.3 Particle SI

The analysis is based on the following variables:

- Dependent variable: absolute and normalized frequency of the particle *si* used non-pronominally (per 1,000 verbs)
- Independent variables: properties of the verb (person and number, animacy, reflexivity, lexical type), variation in the syntactic patterns in the contact position between *si* and the verb

The search was done semi-automatically. A python script was used to search for all the occurences of the word 'si' and some unwanted results were excluded (such as the forms of the 2nd person auxiliary, e.g. Ti *si* gledal. 'You were watching.'). The rest was removed manually, by checking each example. Each example was annotated manually for the criteria described in the manuscript. The 1,375 examples of the use of si were extracted from the corpus. Manually annotated data used in the analysis is shown in the file 3_si_examples.xlsx

The frequency of particle *si* categorized based on person and number is shown below (see file 3_si_person.csv).


```{r include=FALSE}
si_variables=read.delim("si_variables.csv")
si_position=read.csv("si_position.csv")
```

Chi-square tests:

```{r}
chisq.test(table(si_variables$PERSON.NUMBER))
chisq.test(table(si_variables$ANIMACY))
chisq.test(table(si_variables$REFLEXIVITY))
chisq.test(table(si_variables$VOICE))


```
```{r}
# Mosaic plots:
Person = si_variables$PERSON
Number = si_variables$NUMBER
si.person.number = xtabs(~ Person + Number)

# run all the lines of code together for the version from the paper
mosaic(si.person.number, main = "", direction = "v", labeling = labeling_values)
# grid.edit("rect:Person=1,Number=PL", gp = gpar(fill = "gray50"))
# grid.edit("rect:Person=2,Number=PL", gp = gpar(fill = "gray50"))
# grid.edit("rect:Person=3,Number=PL", gp = gpar(fill = "gray50"))
```


Frequency of the particle *si* compared on the basis of grammatical categories: animacy of the subject, reflexivity of the predicate, voice of the predicate:


```{r, include=FALSE}
Animacy = si_variables$ANIMACY
Reflexivity = si_variables$REFLEXIVITY
Voice = si_variables$VOICE
si.variables = xtabs(~ Animacy + Reflexivity + Voice)

# run all the lines of code together for the version from the paper
mosaic(si.variables, main = "", direction = "v", labeling = labeling_values)
# grid.edit("rect:Animacy=ANIMATE,Reflexivity=NON-REFL,Voice=ACTIVE", gp = gpar(fill = "gray50"))
# grid.edit("rect:Animacy=ANIMATE,Reflexivity=NON-REFL,Voice=PASSIVE", gp = gpar(fill = "gray50"))
# grid.edit("rect:Animacy=ANIMATE,Reflexivity=REFL,Voice=ACTIVE", gp = gpar(fill = "gray50"))
# grid.edit("rect:Animacy=ANIMATE,Reflexivity=REFL,Voice=PASSIVE", gp = gpar(fill = "gray50"))

```

The data presenting the analysis of the position of the particle 'si' relative to the verb.

```{r, include=FALSE}
# Barplot:

si_position_table=table(si_position$Contact_position)
reordering <- c("si + V", "si + PPART", "si + Neg + V", "si + AUX + PPART", "AUX + si + PPART", "V + si", "PPART + si", "Neg + V + si", "PPART + AUX + si")
si_position_table = si_position_table[reordering]
barplot(si_position_table, xlab="Position of SI", ylab="Frequency", col = c("gray40", "gray40", "gray40", "gray40", "gray40", "gray80", "gray80", "gray80", "gray80"))

```


### 3.1.4 Auxiliary omission in perfect tense

The quantitative analysis of the use of the -AUX forms is based on the following variables:

- Dependant variable: normalized (to the total number of the examples of the use of the perfect tense) frequency of the –AUX and +AUX forms per location. 
- Independant variables: gender, several categorical linguistic variables: aspect, transitivity, lexical group. 

The automatic search for relevant examples in the Timok corpus made with a user Python scriptrequired all the clauses where perfect participle tense is used. These examples were automatically divided into three groups: clauses with –AUX  perfect forms,  clauses with +AUX  perfect forms and clauses with potential mood (the latter group was subsequently excluded from the analysis). From the total number of 13,233 examples of perfect tense, 8,343 (63.05%) are –AUX forms, 4,890 (36.95%) are +AUX forms.

The file 4_overall_freq.csv shows the frequency of analysed examples of the perfect tense that display +AUX (total_aux) and -AUX (no_aux) pattern per transcript  (normalized per 1,000 occurrences of the perfect tense).


``` {r}
aux = read.csv("4_aux_gramm.csv")
aux = select(aux,   "Perfect",      "Aspect",  "Transitivity", "Lex_group")
aux = mutate_all(aux, as.factor)

aux_chisq = table(aux$Perfect)

```
Chi-square/goodnes of fit test
```{r}
chisq.test(aux_chisq)
```
Logistic regression analysis:
```{r}
aux_fit = glm(Perfect ~ Transitivity + Aspect,  aux, family = "binomial")
summary(aux_fit)
aux_fit2 = glm(Perfect ~   Transitivity +  Lex_group, aux, family = "binomial")
summary(aux_fit2)

```


The distribution of +AUX/-AUX patterns in the overall sample is shown in Figure 9. 


```{r include=FALSE, warning=FALSE}
aux_overall = read.csv("4_aux_overall_freq.csv", sep = ',', header = TRUE, stringsAsFactors = TRUE)
aux_overall1 = aux_overall[c(1,5,6)]

aux_overall1 = melt(aux_overall1)

Figure10 =  ggplot(data =aux_overall1,  aes(x=variable, y=value, fill=variable)) +
  geom_boxplot() +
  theme_light() +
  theme(legend.position="none") +
  scale_fill_manual(values = c("grey89", 'grey48')) +
  scale_x_discrete(labels = c("-AUX",'+AUX')) +
  theme(axis.text = element_text(size = 10), 
        axis.title = element_text(size = 10),
        legend.title = element_text(15))+
    xlab("") + ylab("Normalized frequency")
Figure10
```

Figure 10: +AUX and -AUX frequencies accross speakers in the overall sample

```{r, fig.height=3, fig.width=4, fig.cap="Figure 9: +AUX and -AUX frequencies in the overall sample" }
Figure10
```


Auxiliary omission and verbal categories transitivity, aspect and lexical group:


``` {r}


aux_mosaics=read.delim("4_aux.csv")

# Mosaic plots:

transitivity = table(aux_mosaics$Perfect, aux_mosaics$Transitivity)
dimnames(transitivity) = list(Aux_status = c("AUX", "No_AUX"), Transitivity = c("intrans", "trans"))

mosaic(transitivity, main = "", direction = "v", labeling = labeling_values)
# grid.edit("rect:Aux_status=AUX,Transitivity=trans", gp = gpar(fill = "gray50"))
# grid.edit("rect:Aux_status=AUX,Transitivity=intrans", gp = gpar(fill = "gray50"))

aspect = table(aux_mosaics$Perfect, aux_mosaics$Aspect)
dimnames(aspect) = list(Aux_status = c("AUX", "No_AUX"), Aspect = c("imperf", "perf"))

mosaic(aspect, main = "", direction = "v", labeling = labeling_values)
# grid.edit("rect:Aux_status=AUX,Aspect=perf", gp = gpar(fill = "gray50"))
# grid.edit("rect:Aux_status=AUX,Aspect=imperf", gp = gpar(fill = "gray50"))

lexgroup = table(aux_mosaics$Perfect, aux_mosaics$Lex_group)
dimnames(lexgroup) = list(Aux_status = c("AUX", "No_AUX"), Lexical_group = c("modal", "non-modal"))

mosaic(lexgroup, main = "", direction = "v", labeling = labeling_values)
# grid.edit("rect:Aux_status=AUX,Lexical_group=modal", gp = gpar(fill = "gray50"))
# grid.edit("rect:Aux_status=AUX,Lexical_group=non-modal", gp = gpar(fill = "gray50"))
```


## 3.2 Analysis of the socio-geographic factors

Analysis of social and geographic factors involved the dependent variables:

- proportion of the analytic marking of the indirect object and the possessive per total examples analysed per location
- normalized frequency of PPD per 1,000 nouns per location
- normalized frequency of particle *si* per 1,000 verbs
- normalized frequency of AUX omission per 1,000 cases of perfect tense

The independent variables regarding geographic distribution are:
 
- geographic longitude
- geographic latitude
- altitude
- distance from the city of Knjaževac

The independent variables regarding socio-demographic distribution are:

- age
- gender


### Analysis of the geographic factors

We firstly present the comparison of the linguistic frequencies with geographic vairiables (longitude, latitude, altitude, distance from the city). For the analysis of the geographic variables, frequency values have been aggregated for each location. The dependant variables and the geographic variables are continuous. The dependant variable in all 4 analyses does not have normal distribution, so Kendall's correlation test was used. Geographic distribution of frequencies of each feature is presented on maps. (not included in the manuscript)

#### Marking of indirect object and possessor:


```{r, include=FALSE}
marking_geo = read.csv('1_marking_geo.csv', sep = ",", header = TRUE, na.strings = "")
marking_nouns_geo = read.csv('1_marking_geo_nouns.csv', sep = ",", header = TRUE, na.strings = "")
marking_pronouns_geo = read.csv('1_marking_geo_pronouns.csv', sep = ",", header = TRUE, na.strings = "")

# the dependent variable is not normally distributed
plot(density(marking_geo$FreqNA.ALL))
shapiro.test(marking_geo$FreqNA.ALL)

plot(density(marking_nouns_geo$FreqNA.ALL))
shapiro.test(marking_nouns_geo$FreqNA.ALL)

plot(density(marking_pronouns_geo$FreqNA.ALL))
shapiro.test(marking_pronouns_geo$FreqNA.ALL)

# map 1
marking_map_pal = pal <- colorBin(
  palette = "black",
  domain = marking_geo$FreqNA.ALL)

marking_map <- leaflet(marking_geo) %>%
  addProviderTiles(providers$Stamen.Toner) %>%
  addCircles(lng=~LONGITUDE, lat=~LATITUDE, 
             radius = marking_geo$FreqNA.ALL*marking_geo$FreqNA.ALL/5, 
             color = "Black",
             label = ~LOCATION)


```
```{r}
head(marking_geo)

```


Kendall's rank correlation between analytic case marking frequencies and geographic variables.


```{r}
cor.test(marking_geo$FreqNA.ALL,marking_geo$LONGITUDE, method = c("kendall"))
cor.test(marking_geo$FreqNA.ALL,marking_geo$LATITUDE, method = c("kendall"))
cor.test(marking_geo$FreqNA.ALL,marking_geo$Altitude, method = c("kendall"))
cor.test(marking_geo$FreqNA.ALL,marking_geo$DIST_city, method = c("kendall"))

cor.test(marking_nouns_geo$FreqNA.ALL,marking_nouns_geo$LONGITUDE, method = c("kendall"))
cor.test(marking_nouns_geo$FreqNA.ALL,marking_nouns_geo$LATITUDE, method = c("kendall"))
cor.test(marking_nouns_geo$FreqNA.ALL,marking_nouns_geo$Altitude, method = c("kendall"))
cor.test(marking_nouns_geo$FreqNA.ALL,marking_nouns_geo$DIST_city, method = c("kendall"))

cor.test(marking_pronouns_geo$FreqNA.ALL,marking_pronouns_geo$LONGITUDE, method = c("kendall"))
cor.test(marking_pronouns_geo$FreqNA.ALL,marking_pronouns_geo$LATITUDE, method = c("kendall"))
cor.test(marking_pronouns_geo$FreqNA.ALL,marking_pronouns_geo$Altitude, method = c("kendall"))
cor.test(marking_pronouns_geo$FreqNA.ALL,marking_pronouns_geo$DIST_city, method = c("kendall"))

```


The map presenting the areal distribution of the analytic case marking in IO and POSS:


```{r, fig.width=8, fig.height=4}
marking_map
```


#### Post-positive demonstratives:


```{r, include=FALSE}
ppd_geo = read.csv('2_ppd_geo.csv', sep = ",", header = TRUE, na.strings = "")

# the dependent variable is not normally distributed
plot(density(ppd_geo$art_norm))
shapiro.test(ppd_geo$art_norm)

# map 2
ppd_map_pal = pal <- colorBin(
  palette = "black",
  domain = ppd_geo$art_freq)
ppd_map <- leaflet(ppd_geo) %>%
  addProviderTiles(providers$Stamen.Toner) %>%
  addCircles(lng=~LONGITUDE, lat=~LATITUDE, 
             radius = ppd_geo$art_norm*40, 
             color = "Black",
             label = ~location)

```
```{r}
head(ppd_geo)
```


Kendall's rank correlation between post-positive demonstatives frequencies and geographic variables.


```{r}
cor.test(ppd_geo$art_norm, ppd_geo$LONGITUDE, method = c("kendall"))
cor.test(ppd_geo$art_norm, ppd_geo$LATITUDE, method = c("kendall"))
cor.test(ppd_geo$art_norm, ppd_geo$Altitude, method = c("kendall"))
cor.test(ppd_geo$art_norm, ppd_geo$DIST_city, method = c("kendall"))
```


The map presenting the areal distribution of the post-positive demonstatives:


```{r, fig.width=8, fig.height=4}
ppd_map
```


#### Particle SI:


```{r, include=FALSE}
si_geo=read.csv("si_geo.csv")

# the dependent variable is not normally distributed
plot(density(si_geo$NormFreqSI))
shapiro.test(si_geo$NormFreqSI)

# map 3
si_map_pal = pal <- colorNumeric(
  palette = "black",
  domain = si_geo$NormFreqSI)
si_map <- leaflet(si_geo) %>%
  addProviderTiles(providers$Stamen.Toner)%>%
  addCircles(lng=~LONGITUDE, lat=~LATITUDE, 
             radius = si_geo$NormFreqSI*70, 
             color = "Black",
             label = ~Location)

```
```{r}
head(si_geo)
```


Kendall's rank correlation between particle 'si' frequencies and geographic variables.


```{r}

cor.test(si_geo$NormFreqSI, si_geo$LONGITUDE, method = c("kendall"))
cor.test(si_geo$NormFreqSI, si_geo$LATITUDE, method = c("kendall"))
cor.test(si_geo$NormFreqSI, si_geo$Altitude, method = c("kendall"))
cor.test(si_geo$NormFreqSI, si_geo$DIST_city, method = c("kendall"))

```


The map presenting the areal distribution of the particle 'si':


```{r, fig.width=8, fig.height=4}
si_map
```


#### Auxiliary omission in the perfect tense:


```{r, include=FALSE}
aux_geo = read.csv('4_aux_geo.csv', sep = ",", header = TRUE, na.strings = "")

# the dependent variable is normally distributed
plot(density(aux_geo$perf_no_aux_norm))
shapiro.test(aux_geo$perf_no_aux_norm)

# map 4
aux_map_pal = pal <- colorBin(
  palette = "black",
  domain = aux_geo$no_aux)
aux_map <- leaflet(aux_geo) %>%
  addProviderTiles(providers$Stamen.Toner) %>%
  addCircles(lng=~longitude, lat=~latitude, 
             radius = aux_geo$perf_no_aux_norm*3, 
             color = "Black",
             label = ~LOCATION)
```
```{r}
head(aux_geo)
```


Kendall's rank correlation between Auxiliary omission in the perfect tense frequencies and geographic variables.


```{r}
cor.test(aux_geo$perf_no_aux, aux_geo$longitude, method = c("pearson"))
cor.test(aux_geo$perf_no_aux, aux_geo$latitude, method = c("pearson"))
cor.test(aux_geo$perf_no_aux, aux_geo$Altitude, method = c("pearson"))
cor.test(aux_geo$perf_no_aux, aux_geo$DIST_city, method = c("pearson"))
```


The map presenting the areal distribution of the auxiliary omission in the perfect tense:


```{r, fig.width=8, fig.height=4}
aux_map
```

### Analysis of the socio-demographic factors

What follows is the correlation of the linguistic frequencies with socio-demographic variables (age, gender). For the analysis of the geographic variables, frequency values have been aggregated for each location. The dependant variables is coninuous, while the geographic variables are binary. The dependant variables in all analyses except PPD do not have normal distribution, so Wilcoxon Rank Sum test was used, while for PPD, we used Pearson's rank correlation.


#### Marking of indirect object and possessor:

(see file 1_marking_socio_all.csv)


```{r include=FALSE}
marking_socio=read.csv("1_marking_socio_all.csv")
marking_socio_nouns=read.csv("1_marking_socio_nouns.csv")
marking_socio_pronouns=read.csv("1_marking_socio_pronouns.csv")



# the dependent variable is not normally distributed
plot(density(marking_socio$Freq.NA.Obl..ALL))
shapiro.test(marking_socio$Freq.NA.Obl..ALL)


```


Analytic marking and age:


```{r}
wilcox.test(marking_socio$Freq.NA.Obl..ALL[marking_socio$AGE=="older"], marking_socio$Freq.NA.Obl..ALL[marking_socio$AGE=="younger"], alternative = "two.sided")
wilcox.test(marking_socio_nouns$Freq.NA.Obl..ALL[marking_socio_nouns$AGE=="older"], marking_socio_nouns$Freq.NA.Obl..ALL[marking_socio_nouns$AGE=="younger"], alternative = "two.sided")
wilcox.test(marking_socio_pronouns$Freq.NA.Obl..ALL[marking_socio_pronouns$AGE=="older"], marking_socio_pronouns$Freq.NA.Obl..ALL[marking_socio_pronouns$AGE=="younger"], alternative = "two.sided")
wilcox.test(marking_socio$Freq.NA.Obl..ALL[marking_socio$GENDER=="female"], marking_socio$Freq.NA.Obl..ALL[marking_socio$GENDER=="male"], alternative = "two.sided")
wilcox.test(marking_socio_nouns$Freq.NA.Obl..ALL[marking_socio_nouns$GENDER=="female"], marking_socio_nouns$Freq.NA.Obl..ALL[marking_socio_nouns$GENDER=="male"], alternative = "two.sided")
wilcox.test(marking_socio_pronouns$Freq.NA.Obl..ALL[marking_socio_pronouns$GENDER=="female"], marking_socio_pronouns$Freq.NA.Obl..ALL[marking_socio_pronouns$GENDER=="male"], alternative = "two.sided")


```
```{r}
marking_socio1<-marking_socio[!(marking_socio$AGE=="missing"),]

marking_age_plot = ggplot(data=marking_socio1)+
  geom_boxplot(aes(x=AGE, y=Freq.NA.Obl..ALL, fill = AGE))+
  labs(title = "Analytic case marking", x = NULL, y = "Relative freguency")+
  theme_light() +
  scale_fill_manual(values = c("grey89", 'grey48'))+
  theme(axis.text = element_text(size = 15), 
        axis.title = element_text(size = 20),
        legend.title = element_text(size = 20),
        legend.position = "none", title = element_text(size = 20))


marking_socio2<-marking_socio[!(marking_socio$GENDER=="missing"),]

marking_gender_plot = ggplot(data=marking_socio2)+
  geom_boxplot(aes(x=GENDER, y=Freq.NA.Obl..ALL, fill = GENDER))+
  labs(title = "Analytic case marking", x = NULL, y = "Relative freguency")+
  theme_light() +
  scale_fill_manual(values = c("grey89", 'grey48'))+
  theme(axis.text = element_text(size = 15), 
        axis.title = element_text(size = 20),
        legend.title = element_text(size = 20),
        legend.position = "none", title = element_text(size = 20))
```

#### Post-positive demonstratives:

(see files 2_PPD_age.csv and 2_PPD_gender.csv)

```{r, include=FALSE}
ppd_age = read.csv('2_PPD_age.csv', sep = ',', header = TRUE, stringsAsFactors = TRUE)

# the dependent variable is not normally distributed
plot(density(ppd_age$art_norm_freq))
shapiro.test(ppd_age$art_norm_freq)

ppd_age_plot = ggplot(data=ppd_age)+
  geom_boxplot(aes(x=old, y=art_norm_freq, fill = old))+
  labs(title = "Post-positive demonstratives", x = NULL, y = "Normalized freguency")+
  theme_light() +
  scale_fill_manual(values = c("grey89", 'grey48'))+
  theme(axis.text = element_text(size = 15), 
        axis.title = element_text(size = 20),
        legend.title = element_text(size = 20),
        legend.position = "none", title = element_text(size = 20))

ppd_gender = read.csv('2_PPD_gender.csv', sep = ',', header = TRUE, stringsAsFactors = TRUE)

ppd_gender_plot = ggplot(data=ppd_gender)+
  geom_boxplot(aes(x=gender, y=art_norm_freq, fill = gender))+
  labs(title = "Post-positive demonstratives", x = NULL, y = "Normalized freguency")+
  theme_light() +
  scale_fill_manual(values = c("grey89", 'grey48'))+
  theme(axis.text = element_text(size = 15), 
        axis.title = element_text(size = 20),
        legend.title = element_text(size = 20),
        legend.position = "none", title = element_text(size = 20))

# the dependent variable is not normally distributed
plot(density(ppd_gender$art_norm_freq))
shapiro.test(ppd_gender$art_norm_freq)
```


Post-positive demonstratives and age:


```{r}
head(ppd_age)
```


Wilcoxon Rank Sum test used to compare the distribution accross OLD and YOUNG speakers.


```{r}
wilcox.test(art_norm_freq ~ old, data = ppd_age)
```


Post-positive demonstratives and gender:


```{r}
head(ppd_gender)
```


Wilcoxon Rank Sum test used to compare the distribution accross MALE and FEMALE speakers.


```{r}
wilcox.test(art_norm_freq ~ female, data = ppd_gender)

```

#### Particle SI:

(see file 3_si_socio.csv)


``` {r, include=FALSE}
si_socio=read.delim("3_si_socio.csv")


# the dependent variable is not normally distributed
plot(density(si_socio$Freq.of.SI))
shapiro.test(si_socio$Freq.of.SI)

```


Particle 'si' and age:


```{r}
wilcox.test(si_socio$Freq.of.SI[si_socio$AGE=="younger"], si_socio$Freq.of.SI[si_socio$AGE=="older"], alternative = "two.sided")
wilcox.test(si_socio$Freq.of.SI[si_socio$GENDER=="female"], si_socio$Freq.of.SI[si_socio$GENDER=="male"], alternative = "two.sided")

```
```{r, include=FALSE}
si_age<-si_socio[!(si_socio$AGE=="missing"),]
si_gender<-si_socio[!(si_socio$GENDER=="missing"),]

si_age_plot = ggplot(data=si_age)+
  geom_boxplot(aes(x=AGE, y=Freq.of.SI, fill = AGE))+
  labs(title = "Particle 'si'", x = NULL, y = "Normalized freguency")+
  theme_light() +
  scale_fill_manual(values = c("grey89", 'grey48'))+
  theme(axis.text = element_text(size = 15), 
        axis.title = element_text(size = 20),
        legend.title = element_text(size = 20),
        legend.position = "none", title = element_text(size = 20))

si_gender_plot = ggplot(data=si_gender)+
  geom_boxplot(aes(x=GENDER, y=Freq.of.SI, fill = GENDER))+
  labs(title = "Particle 'si'", x = NULL, y = "Normalized freguency")+
  theme_light() +
  scale_fill_manual(values = c("grey89", 'grey48'))+
  theme(axis.text = element_text(size = 15), 
        axis.title = element_text(size = 20),
        legend.title = element_text(size = 20),
        legend.position = "none", title = element_text(size = 20))

```

#### Auxiliary omission in the perfect tense:

(see files 4_aux_age.csv and 4_aux_gender.csv)


```{r, include=FALSE}
aux_age = read.csv('4_aux_age.csv', sep = ',', header = TRUE, stringsAsFactors = TRUE, na.strings = "")

# the dependent variable is not normally distributed
plot(density(aux_age$perf_no_aux_norm))
shapiro.test(aux_age$perf_no_aux_norm)


aux_age_plot = ggplot(data=aux_age)+
  geom_boxplot(aes(x=old, y=perf_no_aux_norm, fill = old))+
  labs(title = "AUX omission in perfect", x = NULL, y = "Normalized freguency")+
  theme_light() +
  scale_fill_manual(values = c("grey89", 'grey48'))+
  theme(axis.text = element_text(size = 15), 
        axis.title = element_text(size = 20),
        legend.title = element_text(size = 20),
        legend.position = "none", title = element_text(size = 20))

aux_gender = read.csv('4_aux_gender.csv', sep = ',', header = TRUE, stringsAsFactors = TRUE, na.strings = "")

# the dependent variable is not normally distributed
plot(density(aux_gender$perf_no_aux_norm))
shapiro.test(aux_gender$perf_no_aux_norm)


aux_gender_plot = ggplot(data=aux_gender)+
  geom_boxplot(aes(x=gender, y=perf_no_aux_norm, fill = gender))+
  labs(title = "AUX omission in perfect", x = NULL, y = "Normalized freguency")+
  theme_light() +
  scale_fill_manual(values = c("grey89", 'grey48'))+
  theme(axis.text = element_text(size = 15), 
        axis.title = element_text(size = 20),
        legend.title = element_text(size = 20),
        legend.position = "none", title = element_text(size = 20))

```


Auxiliary omission in the perfect tense and age:


```{r}
head(aux_age)
```


Wilcoxon Rank Sum test used to compare the distribution accross OLD and YOUNF speakers.


```{r, warning=FALSE}
wilcox.test(perf_no_aux_norm ~ OLD_1, data = aux_age)
```


Auxiliary omission in the perfect tense and gender:


```{r}
head(aux_gender)
```


Wilcoxon Rank Sum test used to compare the distribution accross MALE and FEMALE speakers.


```{r}
wilcox.test(perf_no_aux_norm ~ female, data = aux_gender)
```


The ranges of values of the lingustic frequencies categorized according to age are shown in Figure 11.

Figure 11: Age


```{r, fig.width=20, fig.height=4.5}
Figure11 = grid.arrange(marking_age_plot, ppd_age_plot, si_age_plot, aux_age_plot, nrow = 1)

```


The ranges of values of the lingustic frequencies categorized according to gender are shown in Figure 12.

Figure 12: Gender


```{r, fig.width=20, fig.height=4.5}
Figure12 = grid.arrange(marking_gender_plot, ppd_gender_plot, si_gender_plot, aux_gender_plot, nrow = 1)

```
